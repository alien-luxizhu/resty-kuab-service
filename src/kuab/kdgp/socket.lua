---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by luxizhu.
--- DateTime: 2021/5/31 16:20
---

local sub = string.sub
local byte = string.byte
local type = type
local setmetatable = setmetatable
local tostring = tostring
local select = select
local ngx = ngx
local table = table
local co_yield = coroutine._yield
local co_create = coroutine._create
local co_status = coroutine._status
local co_resume = coroutine._resume
local codec = require "kuab.kdgp.packet.codec"
local CodecStatus = require "kuab.kdgp.packet.CodecStatus"
local parser = require "kuab.kdgp.packet.parser"

local _M = {}
local mt = { __index = _M }



local co_wrap = function(func)
    local co = co_create(func)
    return function(...)
        if co_status(co) == "suspended" then
            return select(2, co_resume(co, ...))
        else
            return nil, "can't resume a " .. co_status(co) .. " coroutine"
        end
    end
end

function _M.receive_any(self)
    local sock = self.sock
    if not sock then
        return nil, "sock nil"
    end
    -- 不知道数据长度，阻塞
    local bytes, err = sock:receiveany(128)
    if not bytes then
        return "", err
    end
    if #bytes > 0 then
        --ngx.log(ngx.INFO, "@@@@@@@ receive_any ", tostring(bytes))
        self:on_data(bytes)
    end
    return bytes, err
end

_M.read_data = function(self)
    ngx.sleep(0.001)
    return self:receive_any()
end

local function co_read_data(self)
    while true do
        self = co_yield(self:receive_any())
    end
end


 _M.read_data = co_wrap(co_read_data)

function _M:on_data(bytes)
    self.sock.ctx.buffer = self.sock.ctx.buffer .. bytes
    while #self.sock.ctx.buffer > 0 do
        local code, packet_length = codec.decode(self.sock.ctx.buffer)
        if not (code == CodecStatus.CODEC_OK) then
            break
        end
        local buffer = self.sock.ctx.buffer
        self.sock.ctx.buffer = sub(buffer, packet_length + 1)
        local packet = parser(buffer)
        local ctx = self.sock.ctx.response_dict[packet.Context]
        if ctx then
            ctx.response = packet
        end
        -- print(ctx.Context)
    end
end

function _M.new()
    local sock, err = require "kuab.kdgp.tcp-socket".new()
    if not sock then
        return nil, err
    end
    local self = {
        sock = sock,
    }
    setmetatable(self, mt)
    return self
end

function _M.set_timeout(self, timeout)
    local sock = self.sock
    if not sock then
        return nil, "not initialized"
    end

    return sock:settimeout(timeout)
end

function _M.set_timeouts(self, connect_timeout, send_timeout, read_timeout)
    local sock = self.sock
    if not sock then
        return nil, "not initialized"
    end

    return sock:settimeouts(connect_timeout, send_timeout, read_timeout)
end

function _M.connect(self, host, port, opt)
    local sock = self.sock
    if not sock then
        return nil, "not initialized"
    end
    local ok, err = sock:connect(host, port, opt)
    self.ctx = sock.ctx
    return ok, err
end

function _M.set_keepalive(self, ...)
end

function _M.close(self)
    local sock = self.sock
    if not sock then
        return nil, "not initialized"
    end
    return sock:close()
end

function _M.future(self, ctx)

    return {
        await = function(timeout)
            if timeout then
                ctx.timeout = timeout
            else
                timeout = ctx.timeout
            end

            while true do
                ngx.sleep(0.001)
                if ctx.response then
                    break
                end
                local bytes, err = self:read_data()
                if ctx.response then
                    break
                end
                if ngx.now() - ctx.time > timeout then
                    self.sock.ctx.response_dict[ctx.Context] = nil
                    return nil, "timeout"
                end
            end
            self.sock.ctx.response_dict[ctx.Context] = nil
            return ctx.response
        end,
    }
end

---
---@param packet packet_t
function _M.send(self, packet)
    local sock = self.sock
    local body = tostring(packet)
    local ctx = {
        Context = packet.Context,
        time = ngx.now(),
        timeout = 50,
    }
    self.sock.ctx.response_dict[ctx.Context] = ctx
    local bytes, err = sock:send(body)
    if not bytes then
        return nil, err
    end
    return self:future(ctx)
end

return _M
