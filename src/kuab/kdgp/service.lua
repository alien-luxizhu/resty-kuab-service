---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by luxizhu.
--- DateTime: 2021/6/7 12:45
---

local const = require "kuab.kdgp.const"
local kdgp_head_buider = require "kuab.kdgp.header".builder
local kdgp_body_builder = require "kuab.kdgp.body".builder
local packet_builder = require "kuab.kdgp.packet.builder"
local kdgp_socket = require "kuab.kdgp.socket"
local util = require "kuab.util.util"
local config = require "conf.config"
---@type cjson
local cjson = require "cjson"

local pkey = util.read_file(ngx.config.prefix() .. "lua/" .. config.pkey)
ngx.log(ngx.INFO, pkey)
local rsa = require "kuab.util.rsa".new {
    private_key = pkey
}
local appSecret = rsa:private_encrypt(config.appSecret)
appSecret = ngx.encode_base64(appSecret)
local session_token = ""

local _M = {}

local function set_header_default(head_builder)
    -- 应用程序所在机器IP地址，如果服务端不控制，可以不设置，建议设置，便于问题跟踪
    head_builder:SetValue(const.KDGB_AppIP, "127.0.0.1")

    -- 应用程序所在机器MAC地址，如果服务端不控制，可以不设置，建议设置，便于问题跟踪
    head_builder:SetValue(const.KDGB_AppMAC, "34-41-5D-C2-A4-D4")

    -- 应用程序所在机器MAC地址，如果服务端不控制，可以不设置，建议设置，便于问题跟踪
    head_builder:SetValue(const.KDGB_AppName, "V3")

    -- 应用程序二进制文件MD5值，如果服务端不控制，可以不设置
    head_builder:SetValue(const.KDGB_AppSign, "f82e6fa9918acf0f7cf539a44cb2e4f")

    -- 应用程序使用API名称，如果服务端不控制，可以不设置，建议设置，便于问题跟踪，建议设置，便于问题跟踪
    head_builder:SetValue(const.KDGB_ApiName, "V3")

    -- 应用程序使用API版本，如果服务端不控制，可以不设置，建议设置，便于问题跟踪，建议设置，便于问题跟踪
    head_builder:SetValue(const.KDGB_ApiVersion, "3.0")

    -- 设置会话序号（必填），通常用于请求和应答匹配（header_builder自动填）
    -- head_builder:SetValue(const.KDGB_Context, util.makeContext())
end

function _M.logon(socket)
    local head_builder = kdgp_head_buider.new()
    local body_builder = kdgp_body_builder.new()

    set_header_default(head_builder)

    -- 设置会话登录功能号（必填）
    head_builder:SetValue(const.KDGB_MsgType, const.MsgType_Logon)

    -- 设置开发者ID和密码，注意，密码需要用开发者对应的RAS私钥证书文件对开发者密码进行加密
    body_builder:SetValue(const.KDGB_AppID, config.appID)

    --print("pkey = ", pkey, "\n")
    --print("appSecret = ", appSecret, "\n")

    body_builder:SetValue(const.KDGB_AppSecret, appSecret)

    local req_builder = packet_builder.new(head_builder, body_builder)

    local packet = req_builder()
            :fill_crc("00000000")
    return socket:send(packet)

end

function _M.content()
    local socket = kdgp_socket.new()
    local opt = {
        logon = function()
            local socket = socket
            local logon_future = _M.logon(socket)
            return {
                await = function()
                    local res = logon_future.await()
                    local token = res.body_json[1].WORKSKEY
                    ngx.log(ngx.INFO, "******** token: ", token)

                    token = ngx.decode_base64(token)
                    token = rsa:private_decrypt(token)
                    session_token = token
                    ngx.log(ngx.INFO, " ********* session_token: ", token)
                    return token
                end
            }
        end,
    }

    local ok, err = socket:connect(
            config.kdgp_server.host,
            config.kdgp_server.port,
            opt)
    if not ok then
        ngx.print(err)
        return
    end

    local head_builder = kdgp_head_buider.new()
    set_header_default(head_builder)

    -- 设置FS接口标志
    head_builder:SetValue(const.KDGB_FLG_TRAN, "Y")

    -- 设置业务功能号（必填）
    head_builder:SetValue(const.KDGB_MsgType, "KSPB.410512")

    -- 设置业务参数
    local body_builder = kdgp_body_builder.new()
    body_builder:SetValue("F_OP_USER", "123456")
    body_builder:SetValue("F_OP_ROLE", "0")

    local req_builder = packet_builder.new(head_builder, body_builder)

    local packet = req_builder()
            :fill_crc(session_token)

    local future, err = socket:send(packet)
    if not future then
        ngx.print(err)
        return
    end

    local res = future.await()
    local data = cjson.decode(res.body_data)
    setmetatable(data, cjson.array_mt)
    ngx.print(cjson.encode {
        ReplyCode = res.head_json.ReplyCode,
        ReplyMsg = res.head_json.ReplyMsg,
        data = data,
    })
    ngx.exit(200)
end

return _M