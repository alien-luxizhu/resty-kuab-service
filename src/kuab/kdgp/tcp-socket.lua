---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by luxizhu.
--- DateTime: 2021/6/7 9:01
---

local string = string
local sub = string.sub
local byte = string.byte
local type = type
local setmetatable = setmetatable
local tostring = tostring
local select = select
local ngx = ngx
local table = table

local _M = {}
local connection_pool = {}
local pool_max_size = 1

local Queue = {}

function Queue.new()
    return setmetatable({
        buffer = {}
    }, { __index = Queue })
end

function Queue:push(value)
    table.insert(self.buffer, value)
end

function Queue.push_front(value)
    table.insert(self.buffer, 1, value)
end

function Queue:pop()
    return table.remove(self.buffer, 1)
end

function Queue:empty()
    return #self.buffer == 0
end

local function read_receive(ctx)
    local sock = ctx.sock
    if not sock then
        sock = ngx.socket.tcp()
        sock:settimeouts(5000, 5000, 200)
        local ok, err = sock:connect(ctx.host, ctx.port)
        if not ok then
            print(" timer connect err: ", err)
            sock:close()
            ctx.status = -1
            ctx.err = err
            return
        end
        ctx.sock = sock
        ctx.status = 1
        ctx.err = nil
        if ctx.logon then
            ctx.logon_future = ctx.logon()
        end
    end

    local data = ctx.send_buffer:pop()
    while data do
        local ok, err = sock:send(data)
        if not ok then
            ctx.send_buffer:push_front(data)
            ctx.sock = nil
            sock:close()
            return
        end
        data = ctx.send_buffer:pop()
    end

    -- 不知道数据长度，阻塞
    local bytes, err = sock:receiveany(8192)
    if not bytes then
        if not string.match(err, "timeout") then
            ctx.sock = nil
            sock:close()
        end
        return
    end
    if #bytes > 0 then
        ctx.receive_buffer:push(bytes)
        if ctx.logon_future then
            ctx.session_token = ctx.logon_future.await()
            ctx.logon_future = nil
            ctx.status = 2
            ngx.log(ngx.INFO, "###################### session_token ", ctx.session_token)
        end
    end
end

local function timer_socket_func(premature, ctx)
    if premature then
        return
    end
    while true do
        read_receive(ctx)
    end
end

local function roundrobin(index, max)
    return index % max + 1
end

function _M:connect(host, port, opt)
    local key = table.concat({ host, port }, ":")
    local pool = connection_pool[key]
    if not pool then
        pool = {
            index = 0,
        }
        connection_pool[key] = pool
    end
    pool.index = roundrobin(pool.index, pool_max_size)
    local ctx = pool[pool.index]
    if not ctx then
        ctx = {
            host = host,
            port = port,
            status = 0,
            send_buffer = Queue.new(),
            receive_buffer = Queue.new(),
            logon = opt and opt.logon,
            ---
            buffer = "",
            response_dict = {},
        }
        pool[pool.index] = ctx
        ngx.timer.at(0, timer_socket_func, ctx)
    end
    self.ctx = ctx
    while ctx.logon do
        ngx.sleep(0.001)
        if ctx.status == 2 then
            return true
        end
        if ctx.status == -1 then
            return false, ctx.err
        end
    end
    return true
end

function _M:sslhandshake()
end

function _M:send(data)
    self.ctx.send_buffer:push(data)
    ngx.sleep(0.001)
    return #data
end

function _M:receive(size)
    return self.ctx.receive_buffer:pop() or ""
end

function _M:receiveany(max)
    return self.ctx.receive_buffer:pop() or ""
end

function _M:receiveuntil(pattern, options)
    return function()
    end
end

function _M:close()
    return true
end

function _M:settimeout()
end

function _M:settimeouts()
end

function _M:setoption()
    return true
end

function _M:setkeepalive()
    return true
end

function _M:getreusedtimes()
    return 0
end

function _M.new()
    return setmetatable({}, { __index = _M })
end

return _M