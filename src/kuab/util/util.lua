---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by luxizhu.
--- DateTime: 2021/5/31 10:01
---

local ngx = ngx
local table = table
local require = require
local tostring = tostring
local string = string
local math = math
local os = os
local pairs = pairs
local ipairs = ipairs
local setmetatable = setmetatable
local format = string.format
local date = os.date
local const = require "kuab.kdgp.const"
local g_seqnum = 0

local _M = {}

---
---@param value number
---@return string
function _M.itoa(value)
    return format("%08u", value)
end

function _M.std_string(buffer, start, len)
    return string.sub(buffer, start + 1, len and start + len)
end

function _M.makeContext()
    g_seqnum = g_seqnum + 1
    return tostring(g_seqnum)
end

---
---@return string
function _M.GetDatetimeStamp()
    return date("%Y-%m-%d %X.99")
end

---
---@param packet string
---@param session_token string
---@return string
function _M.CalcCrc(packet, session_token)
    local sum = 0
    for i = 1, #session_token do
        sum = sum + string.byte(session_token, i)
    end

    for i = const.kHeadFormatBeginPos + 1, #packet do
        sum = sum + string.byte(packet, i)
    end
    sum = sum % 0xffffffff
    return format("%08x", sum)
end

---
---@param packet packet_t
---@param session_token string
---@return string
function _M.FillCrc(packet, session_token)
    packet.crc = _M.CalcCrc(tostring(packet), session_token)
end

---
---@param packet string
---@param session_token string
---@return boolean
function _M.CheckCrc(packet, session_token)
    local src_crc = string.sub(packet, const.kCRCBeginPos + 1, const.kHeadFormatBeginPos)
    local calc_crc = _M.CalcCrc(packet, session_token)
    return src_crc == calc_crc
end

local function ZeroPadding(s, nBlockSize)
    local nLen = #s
    local paddingCount = nBlockSize - nLen % nBlockSize
    return s .. string.rep("\0", paddingCount)
end

local function gen_key8(k)
    return string.sub(k, 1, 8)
end

local lrucache = require "resty.lrucache"
local cache = lrucache.new(10)
local des = require "resty.des"

local ffi = require "ffi"
local C = ffi.C

local function get_des(key)
    local des1 = cache:get(key)
    if des1 then
        return des1
    end
    local hash = {
        iv = "12345678",
        method = gen_key8
    }
    local err
    des1, err = des:new(key, nil, nil, hash)
    if err then
        error(err)
    end
    C.EVP_CIPHER_CTX_set_padding(des1._encrypt_ctx, 0)
    cache:set(key, des1)
    return des1
end

function _M.read_file(file_path)
    local file, err = io.open(file_path, "rb")
    if not file then
        return nil, "failed to open file: " .. file_path .. ", error info:" .. err
    end

    local data, err = file:read("*all")
    if err ~= nil then
        file:close()
        return nil, "failed to read file: " .. file_path .. ", error info:" .. err
    end

    file:close()
    return data
end

local des_base64 = {}
_M.des = des_base64

function des_base64.Encrypt(key, plain)
    plain = ZeroPadding(plain, 8)
    local encrypted = get_des(key):encrypt(plain)
    encrypted = ngx.encode_base64(encrypted)
    ngx.log(ngx.DEBUG, plain, " --> ", encrypted)
    return encrypted
end

return _M